(define smoke-class-method-hash-size 7919)
(define smoke-class-vector '#())
(define smoke-class->method-vector-cache #f)



(define (smoke-class->method-vector)
  (if (not smoke-class->method-vector-cache)
      (begin 
	(set! smoke-class->method-vector-cache (make-vector (+ 1 (smoke-c-class-count)) '()))
	(let ((maxindex (smoke-c-method-count)))
	  (let add-method ((i 0))
	    (if (< i maxindex)
		(let* ((class-id (smoke-c-method-classId (smoke-c-get-method i)))
		       (current-list (vector-ref smoke-class->method-vector-cache class-id)))
		  (vector-set! smoke-class->method-vector-cache class-id (cons i current-list))
		  (add-method (+ i 1)))
		smoke-class->method-vector-cache))))
      smoke-class->method-vector-cache))

(define (smoke-class-method-ids class-id)
  (vector-ref (smoke-class->method-vector) class-id))

(define (smoke-class-type class)
  (error "implement class type lookup"))
;  (define (find-class-type class)
;    (let loop ((methods (cadr (assq 'methods class))))
;	  (cond ((null? methods) #f)
;		((memq 'ctor (cadr (assq 'flags (car methods)))) (cadr (assq 'return (car methods))))
;		(else (loop (cdr methods))))))

(define (smoke-class-name class)
  (cadr (assq 'name class)))

(define (smoke-class-scm-type class)
  (cadr (assq 'scm-type class)))

(define (smoke-class-external? class)
  (cadr (assq 'external class)))

(define (smoke-class-id class)
  (cadr (assq 'id class)))

(define (smoke-class-methods class)
  (cadr (assq 'methods class)))

(define (smoke-class-parents class)
  (cadr (assq 'inherits class)))

(define (smoke-class-make-inheritance-list start)
  (if (positive? start)
      (let loop ((i start))
	(if (positive? (smoke-c-get-inheritanceList i))
	    (cons (smoke-c-get-inheritanceList i) 
		  (loop (+ i 1)))
	    '()))
      '()))

; something wrong in this function, should be adding disambiguator but isn't so just adding id now
(define (smoke-class-make-method-list index)
  (map (lambda (method-id)
	 (smoke-make-method index method-id 0)) (smoke-class-method-ids index)))

(define (smoke-make-class index)
  (let ((class (smoke-c-get-class index)))
    `((id ,index) 
      (name ,(smoke-c-class-className class))
      (scm-type 'foobar)
      (flags ,(smoke-class-flags-to-symbols (smoke-c-class-flags class)))
      (methods ,(smoke-class-make-method-list index))
      (inherits ,(smoke-class-make-inheritance-list (smoke-c-class-parents class)))
      (external ,(smoke-c-class-external class)))))

;(define (smoke-class-by-name name)
;  (cond ((null? classtree) '())
;	((string=? type (cadr (assq 'name (car classtree)))) (car classtree))
;	(else (class-by-name (cdr classtree) type))))

(define (smoke-class-by-id id)
  (if (not (smoke-c-initialised?))
      (error "You must initialise smoke before using it, try (smoke-init-qt) or (smoke-init-qtwebkit)"))
  (let* ((obj (vector-ref smoke-class-vector id)))
    (if (null? obj)
	(let ((obj (smoke-make-class id)))
	  (vector-set! smoke-class-vector id obj)
	  obj)
	obj)))


(define (smoke-class-by-name name)
  (if (not (smoke-c-initialised?))
      (error "You must initialise smoke before using it, try (smoke-init-qt) or (smoke-init-qtwebkit)"))
  (let loop ((i (smoke-class-min-id))
	     (max (smoke-class-max-id)))
    (cond ((> i max) #f)
	  ((string=? (smoke-class-name (smoke-class-by-id i)) name) (smoke-class-by-id i))
	  (else (loop (+ i 1) max)))))

(define (smoke-class-min-id) 1)

(define (smoke-class-max-id) (- (vector-length smoke-class-vector) 1))

(define (smoke-init family)
  (cond ((eq? family 'qt) (smoke-c-init-qt) (set! smoke-class-vector (make-vector (+ 1 (smoke-c-class-count)) '())))
	((eq? family 'qtwebkit) (smoke-c-init-qtwebkit) (set! smoke-class-vector (make-vector (+ 1 (smoke-c-class-count)) '())))
	(else (error (string-append "Unsupported API " (string->symbol family))))))

(define (smoke-class-subclasses class)
  (let loop ((i (smoke-class-min-id))
	     (max (smoke-class-max-id)))
    (cond ((> i max) '())
	  ((member (smoke-class-id class) (cadr (assq 'inherits (smoke-class-by-id i))))
	   (cons i (loop (+ i 1) max)))
	(else (loop (+ i 1) max)))))

(define (smoke-class-method-by-name class methodname . rest)
  (let loop ((methods (smoke-class-methods class)))
    (cond ((null? methods) '())
	  ((string=? (smoke-method-name (car methods)) methodname) (car methods))
	  (else (loop (cdr methods))))))

(define (smoke-class-method-candidates class excludelist)
  (define hash (smoke-method-candidates-hash-table smoke-class-method-hash-size))
  (define excludehash (exclusion-hash excludelist))
  (define (add-class c)
    (map (lambda (m) (hash 'put m)) (smoke-class-methods c))
    (map (lambda (id) (add-class (smoke-class-by-id id))) (smoke-class-parents c)))
  (define (method-filter m)
;    (print (smoke-method-mangle-name m))
;    (newline)
    (cond ((and (or (constructor? m) (destructor? m))
		(not (= (smoke-method-class m) (smoke-class-id class)))) #f)
	  ((excludehash 'exists (smoke-method-mangle-name m)) #f)
	  ((enum? m) #f)
	  ((public? m) #t)
	  (else #f)))
  (add-class class)
  (map (lambda (m) (smoke-method-modify-class m class))
       (filter method-filter (hash 'all)))
;  (filter method-filter (hash 'all))
  )